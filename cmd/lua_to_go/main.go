package main

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"

	"remembering-home/src/atlases"
	"remembering-home/src/common"
	"remembering-home/src/dialogues"
	"remembering-home/src/enums"

	lua "github.com/yuin/gopher-lua"
)

func main() {
	if len(os.Args) < 2 {
		panic("Usage: lua_to_go --input <lua_file> [--output <go_file>]")
	}

	var inputFile, outputFile string

	// Parse command line arguments
	for i := 1; i < len(os.Args); i++ {
		switch os.Args[i] {
		case "--input":
			if i+1 < len(os.Args) {
				inputFile = os.Args[i+1]
				i++
			} else {
				panic("Error: --input requires a filename")
			}
		case "--output":
			if i+1 < len(os.Args) {
				outputFile = os.Args[i+1]
				i++
			} else {
				panic("Error: --output requires a filename")
			}
		}
	}

	if inputFile == "" {
		panic("Error: --input is required")
	}

	// Validate input file extension
	if !strings.HasSuffix(inputFile, ".lua") {
		panic("Error: input file must have .lua extension")
	}

	// Set output file if not provided
	if outputFile == "" {
		// Extract directory name and create output filename
		// e.g., storage_room/data.lua -> storage_room_data.go
		dir := filepath.Base(filepath.Dir(inputFile))
		outputFile = filepath.Join("src/assets/data/atlases", dir+"_data.go")
	}

	// Read and parse Lua file
	luaData, err := parseLuaFile(inputFile)
	if err != nil {
		panic(fmt.Sprintf("Error parsing Lua file: %v", err))
	}

	// Convert to Go data structures
	goData := convertToGoData(luaData)

	// Generate Go source code
	goCode, err := generateGoCode(goData)
	if err != nil {
		panic(fmt.Sprintf("Error generating Go code: %v", err))
	}

	// Write output file
	if err := os.WriteFile(outputFile, goCode, 0644); err != nil {
		panic(fmt.Sprintf("Error writing output file: %v", err))
	}

	fmt.Printf("Successfully converted %s to %s\n", inputFile, outputFile)
}

func parseLuaFile(filename string) (*lua.LTable, error) {
	L := lua.NewState()
	defer L.Close()

	// Read the Lua file
	content, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	// Execute the Lua code
	if err := L.DoString(string(content)); err != nil {
		return nil, err
	}

	// Get the returned table
	ret := L.Get(-1)
	if ret.Type() != lua.LTTable {
		return nil, fmt.Errorf("expected table, got %s", ret.Type())
	}

	return ret.(*lua.LTable), nil
}

func convertToGoData(luaTable *lua.LTable) []atlases.Data {
	var goData []atlases.Data

	luaTable.ForEach(func(key, value lua.LValue) {
		if value.Type() != lua.LTTable {
			return
		}

		itemTable := value.(*lua.LTable)
		data := convertTableItem(itemTable)
		goData = append(goData, data)
	})

	return goData
}

func convertTableItem(itemTable *lua.LTable) atlases.Data {
	data := atlases.Data{
		Item:      enums.ItemUndefined,
		Name:      "",
		Pos:       common.Vec2{X: 0, Y: 0},
		NoCol:     false,
		ReqColDir: enums.DirectionUndefined,
		Tags:      []enums.ItemClass{},
		Dialogue:  dialogues.DialogueKeys{},
	}

	itemTable.ForEach(func(key, value lua.LValue) {
		switch key.String() {
		case "id":
			if value.Type() == lua.LTString {
				data.Item = enums.Item(value.String())
			}
		case "name":
			if value.Type() == lua.LTString {
				data.Name = value.String()
			}
		case "x":
			if value.Type() == lua.LTNumber {
				data.Pos.X = float64(value.(lua.LNumber))
			}
		case "y":
			if value.Type() == lua.LTNumber {
				data.Pos.Y = float64(value.(lua.LNumber))
			}
		case "no_col":
			if value.Type() == lua.LTBool {
				data.NoCol = bool(value.(lua.LBool))
			}
		case "req_col_dir":
			if value.Type() == lua.LTNumber {
				dir := int(value.(lua.LNumber))
				switch dir {
				case -1:
					data.ReqColDir = enums.DirectionLeft
				case 1:
					data.ReqColDir = enums.DirectionRight
				default:
					data.ReqColDir = enums.DirectionUndefined
				}
			}
		case "is_door":
			if value.Type() == lua.LTBool && bool(value.(lua.LBool)) {
				data.Tags = append(data.Tags, enums.ItemClassDoor)
			}
		case "dialogue":
			if value.Type() == lua.LTTable {
				dialogueTable := value.(*lua.LTable)
				if dialogueTable.Len() >= 2 {
					roomID := dialogueTable.RawGetInt(1)
					itemID := dialogueTable.RawGetInt(2)
					if roomID.Type() == lua.LTString && itemID.Type() == lua.LTString {
						data.Dialogue = dialogues.DialogueKeys{
							Room: enums.Room(roomID.String()),
							Item: enums.Item(itemID.String()),
						}
					}
				}
			}
		}
	})

	return data
}

func generateGoCode(data []atlases.Data) ([]byte, error) {
	var buf strings.Builder

	// Package declaration
	buf.WriteString("// Code generated by lua_to_go. DO NOT EDIT.\n")
	buf.WriteString("package atlases\n\n")

	// Imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"remembering-home/src/atlases\"\n")
	buf.WriteString("\t\"remembering-home/src/common\"\n")
	buf.WriteString("\t\"remembering-home/src/dialogues\"\n")
	buf.WriteString("\t\"remembering-home/src/enums\"\n")
	buf.WriteString(")\n\n")

	// Variable declaration
	buf.WriteString("var Data = []atlases.Data{\n")

	for _, item := range data {
		buf.WriteString("\t{\n")
		buf.WriteString(fmt.Sprintf("\t\tItem: enums.%s,\n", item.Item.Constant()))
		if item.Name != "" {
			buf.WriteString(fmt.Sprintf("\t\tName: \"%s\",\n", item.Name))
		}
		buf.WriteString(fmt.Sprintf("\t\tPos: common.Vec2{X: %g, Y: %g},\n", item.Pos.X, item.Pos.Y))
		if item.NoCol {
			buf.WriteString("\t\tNoCol: true,\n")
		}
		if item.ReqColDir != enums.DirectionUndefined {
			var dirStr string
			switch item.ReqColDir {
			case enums.DirectionLeft:
				dirStr = "DirectionLeft"
			case enums.DirectionRight:
				dirStr = "DirectionRight"
			default:
				dirStr = "DirectionUndefined"
			}
			buf.WriteString(fmt.Sprintf("\t\tReqColDir: enums.%s,\n", dirStr))
		}
		if len(item.Tags) > 0 {
			buf.WriteString("\t\tTags: []enums.ItemClass{")
			for i, tag := range item.Tags {
				if i > 0 {
					buf.WriteString(", ")
				}
				buf.WriteString(fmt.Sprintf("enums.%s", tag.Constant()))
			}
			buf.WriteString("},\n")
		}
		if item.Dialogue.Room != enums.RoomUndefined || item.Dialogue.Item != enums.ItemUndefined {
			buf.WriteString("\t\tDialogue: dialogues.DialogueKeys{\n")
			if item.Dialogue.Room != enums.RoomUndefined {
				buf.WriteString(fmt.Sprintf("\t\t\tRoom: enums.%s,\n", item.Dialogue.Room.Constant()))
			}
			if item.Dialogue.Item != enums.ItemUndefined {
				buf.WriteString(fmt.Sprintf("\t\t\tItem: enums.%s,\n", item.Dialogue.Item.Constant()))
			}
			buf.WriteString("\t\t},\n")
		}
		buf.WriteString("\t},\n")
	}

	buf.WriteString("}\n")

	// Format the code
	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return nil, err
	}

	return formatted, nil
}
